<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchange.source.qmr_exchange API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchange.source.qmr_exchange</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import datetime
from decimal import Decimal
from typing import List, Union
import pandas as pd
from enum import Enum
from ._utils import get_datetime_range, get_random_string

class OrderSide(Enum):
    BUY = &#39;buy&#39;
    SELL = &#39;sell&#39;


class LimitOrder():

    def __init__(self, ticker, price, qty, creator, side, dt=None):
        self.id = get_random_string()
        self.ticker: str = ticker
        self.price: Decimal = price
        self.type: OrderSide = side
        self.qty: int = qty
        self.creator: str = creator
        self.dt: datetime = dt if dt else datetime.now()

    def to_dict(self):
        return {
            &#39;id&#39;: self.id,
            &#39;ticker&#39;: self.ticker,
            &#39;price&#39;: self.price,
            &#39;qty&#39;: self.qty,
            &#39;creator&#39;: self.creator,
            &#39;dt&#39;: self.dt
        }

    def __repr__(self):
        return f&#39;&lt;LimitOrder: {self.ticker} {self.qty}@{self.price}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;LimitOrder: {self.ticker} {self.qty}@{self.price}&gt;&#39;


class OrderBook():
    &#34;&#34;&#34;An OrderBook contains all the relevant trading data of a given asset. It contains the list of bids and asks, ordered by their place in the queue.
    &#34;&#34;&#34;
    def __init__(self, ticker:str):
        &#34;&#34;&#34;_summary_

        Args:
            ticker (str): the corresponding asset that is going to be traded in the OrderBook.
        &#34;&#34;&#34;
        self.ticker = ticker
        self.bids: List[LimitOrder] = []
        self.asks: List[LimitOrder] = []

    def __repr__(self):
        return f&#39;&lt;OrderBook: {self.ticker}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;OrderBook: {self.ticker}&gt;&#39;
    


    @property
    def df(self) -&gt; dict:
        &#34;&#34;&#34;_summary_

        Returns:
            dict: dictionary with two dataframes corresponding to the bids and asks of the OrderBook
        &#34;&#34;&#34;
        return {
            &#39;bids&#39;: pd.DataFrame.from_records([b.to_dict() for b in self.bids]),
            &#39;asks&#39;: pd.DataFrame.from_records([a.to_dict() for a in self.asks])
        }


class Trade():
    def __init__(self, ticker, qty, price, buyer, seller, dt=None):
        self.ticker = ticker
        self.qty = qty
        self.price = price
        self.buyer = buyer
        self.seller = seller
        self.dt = dt if dt else datetime.now()

    def __repr__(self):
        return f&#39;&lt;Trade: {self.ticker} {self.qty}@{self.price} {self.dt}&gt;&#39;

    def to_dict(self):
        return {
            &#39;dt&#39;: self.dt,
            &#39;ticker&#39;: self.ticker,
            &#39;qty&#39;: self.qty,
            &#39;price&#39;: self.price,
            &#39;buyer&#39;: self.buyer,
            &#39;seller&#39;: self.seller
        }


class Exchange():
    
    def __init__(self, datetime= None):
        self.books = {}
        self.trade_log: List[Trade] = []
        self.datetime = datetime
        self.agents_aum_updates = []

    def __str__(self):
        return &#39;, &#39;.join(ob for ob in self.books)

    def create_asset(self, ticker: str, seed_price=100, seed_bid=.99, seed_ask=1.01):
        &#34;&#34;&#34;_summary_

        Args:
            ticker (str): the ticker of the new asset
            seed_price (int, optional): Price of an initial trade that is created for ease of use. Defaults to 100.
            seed_bid (float, optional): Limit price of an initial buy order, expressed as percentage of the seed_price. Defaults to .99.
            seed_ask (float, optional): Limit price of an initial sell order, expressed as percentage of the seed_price. Defaults to 1.01.
        &#34;&#34;&#34;
        self.books[ticker] = OrderBook(ticker)
        self._process_trade(ticker, 1, seed_price, &#39;init_seed&#39;, &#39;init_seed&#39;,)
        self.limit_buy(ticker, seed_bid, 10, &#39;init_seed&#39;)
        self.limit_sell(ticker, seed_ask, 10, &#39;init_seed&#39;)


    def get_order_book(self, ticker: str) -&gt; OrderBook:
        &#34;&#34;&#34;Returns the OrderBook of a given Asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            OrderBook: the orderbook of the asset.
        &#34;&#34;&#34;
        return self.books[ticker]

    def _process_trade(self, ticker, qty, price, buyer, seller):
        self.trade_log.append(
            Trade(ticker, qty, price, buyer, seller,self.datetime)
        )
        self.agents_aum_updates.extend([[buyer,-qty*price],[seller,qty*price]])
        
    

    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Retrieves the most recent trade of a given asset

        Args:
            ticker (str): the ticker of the trade

        Returns:
            Trade
        &#34;&#34;&#34;
        return next(trade for trade in self.trade_log[::-1] if trade.ticker == ticker)

    def get_trades(self, ticker:str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Retrieves all past trades of a given asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            pd.DataFrame: a dataframe containing all trades
        &#34;&#34;&#34;
        return pd.DataFrame.from_records([t.to_dict() for t in self.trade_log if t.ticker == ticker]).set_index(&#39;dt&#39;).sort_index()

    def get_quotes(self, ticker):
        # TODO: if more than one order has the best price, add the quantities.
        # TODO: check if corresponding quotes exist in order to avoid exceptions
        best_bid = self.books[ticker].bids[0]
        best_ask = self.books[ticker].asks[0]
        quotes = {
            &#39;ticker&#39;: ticker,
            &#39;bid_qty&#39;: best_bid.qty,
            &#39;bid_p&#39;: best_bid.price,
            &#39;ask_qty&#39;: best_ask.qty,
            &#39;ask_p&#39;: best_ask.price,
        }
        return quotes

    def get_best_bid(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;retrieves the current best bid in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset.

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        if self.books[ticker].bids:
            return self.books[ticker].bids[0]

    def get_best_ask(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;retrieves the current best ask in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset.

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        if self.books[ticker].asks:
            return self.books[ticker].asks[0]

    def get_midprice(self, ticker:str) -&gt; float:
        &#34;&#34;&#34;Returns the current midprice of the best bid and ask quotes.

        Args:
            ticker (str): the ticker of the asset

        Returns:
            float: the current midprice
        &#34;&#34;&#34;
        quotes = self.get_quotes(ticker)
        return (quotes[&#39;bid_p&#39;] + quotes[&#39;ask_p&#39;]) / 2

    def limit_buy(self, ticker: str, price: float, qty: int, creator: str):
        price = round(price,2)
        # check if we can match trades before submitting the limit order
        while qty &gt; 0:
            best_ask = self.get_best_ask(ticker)
            if best_ask and price &gt;= best_ask.price:
                trade_qty = min(qty, best_ask.qty)
                self._process_trade(ticker, trade_qty,
                                    best_ask.price, creator, best_ask.creator)
                qty -= trade_qty
                self.books[ticker].asks[0].qty -= trade_qty
                self.books[ticker].asks = [
                    ask for ask in self.books[ticker].asks if ask.qty &gt; 0]
            else:
                break
        queue = len(self.books[ticker].bids)
        for idx, order in enumerate(self.books[ticker].bids):
            if price &gt; order.price:
                queue = idx
                break
        new_order = LimitOrder(ticker, price, qty, creator, OrderSide.BUY, self.datetime)
        self.books[ticker].bids.insert(queue, new_order)
        return new_order


    def limit_sell(self, ticker: str, price: float, qty: int, creator: str):
        price = round(price,2)
        # check if we can match trades before submitting the limit order
        while qty &gt; 0:
            best_bid = self.get_best_bid(ticker)
            if best_bid and price &lt;= best_bid.price:
                trade_qty = min(qty, best_bid.qty)
                self._process_trade(ticker, trade_qty,
                                    best_bid.price, best_bid.creator, creator)
                qty -= trade_qty
                self.books[ticker].bids[0].qty -= trade_qty
                self.books[ticker].bids = [
                    bid for bid in self.books[ticker].bids if bid.qty &gt; 0]
            else:
                break
        queue = len(self.books[ticker].asks)
        for idx, order in enumerate(self.books[ticker].asks):
            if price &lt; order.price:
                queue = idx
                break
        new_order = LimitOrder(ticker, price, qty, creator, OrderSide.SELL, self.datetime)
        self.books[ticker].asks.insert(queue, new_order)
        return new_order

    def cancel_order(self, id):
        for book in self.exchange.books:
            bid = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].bids) if o.id == id),None)
            if bid:
                self.exchange.books[book].bids[bid[0]]
                self.exchange.books[book].bids.pop(bid[0])
                return bid
            ask = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].asks) if o.id == id),None)
            if ask:
                self.exchange.books[book].asks.pop(ask[0])
                return ask
        return None

    def cancel_all_orders(self, agent, ticker):
        self.books[ticker].bids = [b for b in self.books[ticker].bids if b.creator != agent]
        self.books[ticker].asks = [a for a in self.books[ticker].asks if a.creator != agent]
        return None

    def market_buy(self, ticker: str, qty: int, buyer: str):
        for idx, ask in enumerate(self.books[ticker].asks):
            trade_qty = min(ask.qty, qty)
            self.books[ticker].asks[idx].qty -= trade_qty
            qty -= trade_qty
            self._process_trade(ticker, trade_qty,
                                ask.price, buyer, ask.creator)
            if qty == 0:
                break
        self.books[ticker].asks = [
            ask for ask in self.books[ticker].asks if ask.qty &gt; 0]

    def market_sell(self, ticker: str, qty: int, seller: str):
        for idx, bid in enumerate(self.books[ticker].bids):
            trade_qty = min(bid.qty, qty)
            self.books[ticker].bids[idx].qty -= trade_qty
            qty -= trade_qty
            self._process_trade(ticker, trade_qty,
                                bid.price, bid.creator, seller)
            if qty == 0:
                break
        self.books[ticker].bids = [
            bid for bid in self.books[ticker].bids if bid.qty &gt; 0]

    def _set_datetime(self, dt):
        self.datetime = dt



class Agent():
    &#34;&#34;&#34;The Agent class is the base class for developing different traders that participate in the simulated exchange.
    &#34;&#34;&#34;
    def __init__(self, name:str, tickers:List[str], aum:int=10_000):
        self.name = name
        self.tickers = tickers
        self.exchange:Exchange = None
        self.aum = aum

    def __repr__(self):
        return f&#39;&lt;Agent: {self.name}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;Agent: {self.name}&gt;&#39;

    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Returns the most recent trade of a given asset

        Args:
            ticker (str): the ticker of the corresponding asset

        Returns:
            Trade: the most recent trade
        &#34;&#34;&#34;
        return self.exchange.get_latest_trade(ticker)

    def get_best_bid(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;Returns the current best limit buy order

        Args:
            ticker (str): the ticker of the asset

        Returns:
            LimitOrder: the current best limit buy order
        &#34;&#34;&#34;
        return self.exchange.get_best_bid(ticker)

    def get_best_ask(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;Returns the current best limit sell order

        Args:
            ticker (str): the ticker of the asset

        Returns:
            LimitOrder: the current best limit sell order
        &#34;&#34;&#34;
        return self.exchange.get_best_ask(ticker)
    
    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Returns the latest trade of a given asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            Trade: the latest trade of the asset
        &#34;&#34;&#34;
        return self.exchange.get_latest_trade(ticker)
        
    def get_midprice(self, ticker:str) -&gt; float:
        &#34;&#34;&#34;Returns the current midprice of the best bid and ask orders in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            float: the current midprice
        &#34;&#34;&#34;
        return self.get_midprice(ticker)

    def get_order_book(self,ticker):
        return self.exchange.get_order_book(ticker)

    def get_quotes(self,ticker):
        return self.exchange.get_quotes(ticker)

    def get_trades(self, ticker):
        return self.exchange.get_trades(ticker)

    def market_buy(self, ticker:str, qty:int):
        &#34;&#34;&#34;Places a market buy order. The order executes automatically at the best sell price if ask quotes are available.

        Args:
            ticker (str): the ticker of the asset.
            qty (int): the quantity of the asset to be acquired (in units)

        &#34;&#34;&#34;
        return self.exchange.market_buy(ticker, qty, self.name)

    def market_sell(self, ticker:str, qty:int):
        &#34;&#34;&#34;Places a market sell order. The order executes automatically at the best buy price if bid quotes are available.

        Args:
            ticker (str): the ticker of the asset.
            qty (int): the quantity of the asset to be sold (in units)

        &#34;&#34;&#34;
        return self.exchange.market_sell(ticker, qty, self.name)

    def limit_buy(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
        &#34;&#34;&#34;Creates a limit buy order for a given asset and quantity at a certain price.

        Args:
            ticker (str): the ticker of the asset
            price (float): the limit price
            qty (int): the quantity to be acquired

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        return self.exchange.limit_buy(ticker,price,qty,self.name)

    def limit_sell(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
        &#34;&#34;&#34;Creates a limit sell order for a given asset and quantity at a certain price.

        Args:
            ticker (str): the ticker of the asset
            price (float): the limit price
            qty (int): the quantity to be sold

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        return self.exchange.limit_sell(ticker,price,qty,self.name)

    def _set_exchange(self,exchange):
        self.exchange = exchange

    def cancel_order(self, id:str) -&gt; Union[LimitOrder,None]:
        &#34;&#34;&#34;Cancels the order with a given id (if it exists)

        Args:
            id (str): the id of the limit order

        Returns:
            Union[LimitOrder,None]: the cancelled order if it is still pending. None if it does not exists or has already been filled/cancelled
        &#34;&#34;&#34;
        self.exchange.cancel_order(id=id)

    def cancel_all_orders(self, ticker:str):
        &#34;&#34;&#34;Cancels all remaining orders that the agent has on an asset.

        Args:
            ticker (str): the ticker of the asset.
        &#34;&#34;&#34;
        self.exchange.cancel_all_orders(self.name,ticker)

    def next(self):  
        pass

class Simulator():
    def __init__(self, from_date=datetime(2022,1,1), to_date=datetime(2022,12,31), time_unit=&#39;day&#39;):
        self.datetime_range = iter(get_datetime_range(from_date,to_date,time_unit))
        self.dt = from_date
        self.agents = []
        self.exchange = Exchange(datetime=from_date)

    
    def add_agent(self,agent:Agent):
        # TODO: check that no existing agent already has the same name
        agent._set_exchange(self.exchange)
        self.agents.append(agent)

    def next(self):
        try:
            self.exchange._set_datetime(self.dt)
            for agent in self.agents:
                agent.next()
            self.dt = next(self.datetime_range)
            self.__update_agents_aum()
            return True
        except StopIteration:
            return False
    def run(self):
        while True:
            if not self.next():
                break

    def get_price_bars(self, bar_size=&#39;1D&#39;):
        df = self.trades.resample(bar_size).agg({&#39;price&#39;: &#39;ohlc&#39;, &#39;qty&#39;: &#39;sum&#39;})
        df.columns = df.columns.droplevel()
        df.rename(columns={&#39;qty&#39;:&#39;volume&#39;},inplace=True)
        return df

    @property
    def trades(self):
        return pd.DataFrame.from_records([t.to_dict() for t in self.exchange.trade_log]).set_index(&#39;dt&#39;)

    def __update_agents_aum(self):
        for update in self.exchange.agents_aum_updates:
            agent_idx = self.__get_agent_index(update[0])
            # Check if not None because initial seed is not an agent
            if agent_idx:
                self.agents[agent_idx].aum += update[1]
        self.exchange.agents_aum_updates = []


    def __get_agent_index(self,agent_name):
        return next((index for (index, d) in enumerate(self.agents) if d.name == agent_name), None)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchange.source.qmr_exchange.Agent"><code class="flex name class">
<span>class <span class="ident">Agent</span></span>
<span>(</span><span>name: str, tickers: List[str], aum: int = 10000)</span>
</code></dt>
<dd>
<div class="desc"><p>The Agent class is the base class for developing different traders that participate in the simulated exchange.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Agent():
    &#34;&#34;&#34;The Agent class is the base class for developing different traders that participate in the simulated exchange.
    &#34;&#34;&#34;
    def __init__(self, name:str, tickers:List[str], aum:int=10_000):
        self.name = name
        self.tickers = tickers
        self.exchange:Exchange = None
        self.aum = aum

    def __repr__(self):
        return f&#39;&lt;Agent: {self.name}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;Agent: {self.name}&gt;&#39;

    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Returns the most recent trade of a given asset

        Args:
            ticker (str): the ticker of the corresponding asset

        Returns:
            Trade: the most recent trade
        &#34;&#34;&#34;
        return self.exchange.get_latest_trade(ticker)

    def get_best_bid(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;Returns the current best limit buy order

        Args:
            ticker (str): the ticker of the asset

        Returns:
            LimitOrder: the current best limit buy order
        &#34;&#34;&#34;
        return self.exchange.get_best_bid(ticker)

    def get_best_ask(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;Returns the current best limit sell order

        Args:
            ticker (str): the ticker of the asset

        Returns:
            LimitOrder: the current best limit sell order
        &#34;&#34;&#34;
        return self.exchange.get_best_ask(ticker)
    
    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Returns the latest trade of a given asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            Trade: the latest trade of the asset
        &#34;&#34;&#34;
        return self.exchange.get_latest_trade(ticker)
        
    def get_midprice(self, ticker:str) -&gt; float:
        &#34;&#34;&#34;Returns the current midprice of the best bid and ask orders in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            float: the current midprice
        &#34;&#34;&#34;
        return self.get_midprice(ticker)

    def get_order_book(self,ticker):
        return self.exchange.get_order_book(ticker)

    def get_quotes(self,ticker):
        return self.exchange.get_quotes(ticker)

    def get_trades(self, ticker):
        return self.exchange.get_trades(ticker)

    def market_buy(self, ticker:str, qty:int):
        &#34;&#34;&#34;Places a market buy order. The order executes automatically at the best sell price if ask quotes are available.

        Args:
            ticker (str): the ticker of the asset.
            qty (int): the quantity of the asset to be acquired (in units)

        &#34;&#34;&#34;
        return self.exchange.market_buy(ticker, qty, self.name)

    def market_sell(self, ticker:str, qty:int):
        &#34;&#34;&#34;Places a market sell order. The order executes automatically at the best buy price if bid quotes are available.

        Args:
            ticker (str): the ticker of the asset.
            qty (int): the quantity of the asset to be sold (in units)

        &#34;&#34;&#34;
        return self.exchange.market_sell(ticker, qty, self.name)

    def limit_buy(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
        &#34;&#34;&#34;Creates a limit buy order for a given asset and quantity at a certain price.

        Args:
            ticker (str): the ticker of the asset
            price (float): the limit price
            qty (int): the quantity to be acquired

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        return self.exchange.limit_buy(ticker,price,qty,self.name)

    def limit_sell(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
        &#34;&#34;&#34;Creates a limit sell order for a given asset and quantity at a certain price.

        Args:
            ticker (str): the ticker of the asset
            price (float): the limit price
            qty (int): the quantity to be sold

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        return self.exchange.limit_sell(ticker,price,qty,self.name)

    def _set_exchange(self,exchange):
        self.exchange = exchange

    def cancel_order(self, id:str) -&gt; Union[LimitOrder,None]:
        &#34;&#34;&#34;Cancels the order with a given id (if it exists)

        Args:
            id (str): the id of the limit order

        Returns:
            Union[LimitOrder,None]: the cancelled order if it is still pending. None if it does not exists or has already been filled/cancelled
        &#34;&#34;&#34;
        self.exchange.cancel_order(id=id)

    def cancel_all_orders(self, ticker:str):
        &#34;&#34;&#34;Cancels all remaining orders that the agent has on an asset.

        Args:
            ticker (str): the ticker of the asset.
        &#34;&#34;&#34;
        self.exchange.cancel_all_orders(self.name,ticker)

    def next(self):  
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchange.source.agents.NaiveMarketMaker" href="agents.html#exchange.source.agents.NaiveMarketMaker">NaiveMarketMaker</a></li>
<li><a title="exchange.source.agents.RandomMarketTaker" href="agents.html#exchange.source.agents.RandomMarketTaker">RandomMarketTaker</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchange.source.qmr_exchange.Agent.cancel_all_orders"><code class="name flex">
<span>def <span class="ident">cancel_all_orders</span></span>(<span>self, ticker: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancels all remaining orders that the agent has on an asset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_all_orders(self, ticker:str):
    &#34;&#34;&#34;Cancels all remaining orders that the agent has on an asset.

    Args:
        ticker (str): the ticker of the asset.
    &#34;&#34;&#34;
    self.exchange.cancel_all_orders(self.name,ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.cancel_order"><code class="name flex">
<span>def <span class="ident">cancel_order</span></span>(<span>self, id: str) ‑> Optional[<a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Cancels the order with a given id (if it exists)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>the id of the limit order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a>,None]</code></dt>
<dd>the cancelled order if it is still pending. None if it does not exists or has already been filled/cancelled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_order(self, id:str) -&gt; Union[LimitOrder,None]:
    &#34;&#34;&#34;Cancels the order with a given id (if it exists)

    Args:
        id (str): the id of the limit order

    Returns:
        Union[LimitOrder,None]: the cancelled order if it is still pending. None if it does not exists or has already been filled/cancelled
    &#34;&#34;&#34;
    self.exchange.cancel_order(id=id)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_best_ask"><code class="name flex">
<span>def <span class="ident">get_best_ask</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current best limit sell order</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></code></dt>
<dd>the current best limit sell order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_ask(self, ticker:str) -&gt; LimitOrder:
    &#34;&#34;&#34;Returns the current best limit sell order

    Args:
        ticker (str): the ticker of the asset

    Returns:
        LimitOrder: the current best limit sell order
    &#34;&#34;&#34;
    return self.exchange.get_best_ask(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_best_bid"><code class="name flex">
<span>def <span class="ident">get_best_bid</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current best limit buy order</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></code></dt>
<dd>the current best limit buy order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_bid(self, ticker:str) -&gt; LimitOrder:
    &#34;&#34;&#34;Returns the current best limit buy order

    Args:
        ticker (str): the ticker of the asset

    Returns:
        LimitOrder: the current best limit buy order
    &#34;&#34;&#34;
    return self.exchange.get_best_bid(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_latest_trade"><code class="name flex">
<span>def <span class="ident">get_latest_trade</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.Trade" href="#exchange.source.qmr_exchange.Trade">Trade</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the latest trade of a given asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="exchange.source.qmr_exchange.Trade" href="#exchange.source.qmr_exchange.Trade">Trade</a></code></dt>
<dd>the latest trade of the asset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_trade(self, ticker:str) -&gt; Trade:
    &#34;&#34;&#34;Returns the latest trade of a given asset

    Args:
        ticker (str): the ticker of the asset

    Returns:
        Trade: the latest trade of the asset
    &#34;&#34;&#34;
    return self.exchange.get_latest_trade(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_midprice"><code class="name flex">
<span>def <span class="ident">get_midprice</span></span>(<span>self, ticker: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current midprice of the best bid and ask orders in the orderbook of an asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the current midprice</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_midprice(self, ticker:str) -&gt; float:
    &#34;&#34;&#34;Returns the current midprice of the best bid and ask orders in the orderbook of an asset

    Args:
        ticker (str): the ticker of the asset

    Returns:
        float: the current midprice
    &#34;&#34;&#34;
    return self.get_midprice(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_order_book"><code class="name flex">
<span>def <span class="ident">get_order_book</span></span>(<span>self, ticker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_order_book(self,ticker):
    return self.exchange.get_order_book(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_quotes"><code class="name flex">
<span>def <span class="ident">get_quotes</span></span>(<span>self, ticker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_quotes(self,ticker):
    return self.exchange.get_quotes(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.get_trades"><code class="name flex">
<span>def <span class="ident">get_trades</span></span>(<span>self, ticker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trades(self, ticker):
    return self.exchange.get_trades(ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.limit_buy"><code class="name flex">
<span>def <span class="ident">limit_buy</span></span>(<span>self, ticker: str, price: float, qty: int) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a limit buy order for a given asset and quantity at a certain price.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>float</code></dt>
<dd>the limit price</dd>
<dt><strong><code>qty</code></strong> :&ensp;<code>int</code></dt>
<dd>the quantity to be acquired</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LimitOrder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_buy(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
    &#34;&#34;&#34;Creates a limit buy order for a given asset and quantity at a certain price.

    Args:
        ticker (str): the ticker of the asset
        price (float): the limit price
        qty (int): the quantity to be acquired

    Returns:
        LimitOrder
    &#34;&#34;&#34;
    return self.exchange.limit_buy(ticker,price,qty,self.name)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.limit_sell"><code class="name flex">
<span>def <span class="ident">limit_sell</span></span>(<span>self, ticker: str, price: float, qty: int) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a limit sell order for a given asset and quantity at a certain price.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>float</code></dt>
<dd>the limit price</dd>
<dt><strong><code>qty</code></strong> :&ensp;<code>int</code></dt>
<dd>the quantity to be sold</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LimitOrder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_sell(self, ticker:str, price:float, qty:int) -&gt; LimitOrder:
    &#34;&#34;&#34;Creates a limit sell order for a given asset and quantity at a certain price.

    Args:
        ticker (str): the ticker of the asset
        price (float): the limit price
        qty (int): the quantity to be sold

    Returns:
        LimitOrder
    &#34;&#34;&#34;
    return self.exchange.limit_sell(ticker,price,qty,self.name)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.market_buy"><code class="name flex">
<span>def <span class="ident">market_buy</span></span>(<span>self, ticker: str, qty: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Places a market buy order. The order executes automatically at the best sell price if ask quotes are available.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset.</dd>
<dt><strong><code>qty</code></strong> :&ensp;<code>int</code></dt>
<dd>the quantity of the asset to be acquired (in units)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def market_buy(self, ticker:str, qty:int):
    &#34;&#34;&#34;Places a market buy order. The order executes automatically at the best sell price if ask quotes are available.

    Args:
        ticker (str): the ticker of the asset.
        qty (int): the quantity of the asset to be acquired (in units)

    &#34;&#34;&#34;
    return self.exchange.market_buy(ticker, qty, self.name)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.market_sell"><code class="name flex">
<span>def <span class="ident">market_sell</span></span>(<span>self, ticker: str, qty: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Places a market sell order. The order executes automatically at the best buy price if bid quotes are available.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset.</dd>
<dt><strong><code>qty</code></strong> :&ensp;<code>int</code></dt>
<dd>the quantity of the asset to be sold (in units)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def market_sell(self, ticker:str, qty:int):
    &#34;&#34;&#34;Places a market sell order. The order executes automatically at the best buy price if bid quotes are available.

    Args:
        ticker (str): the ticker of the asset.
        qty (int): the quantity of the asset to be sold (in units)

    &#34;&#34;&#34;
    return self.exchange.market_sell(ticker, qty, self.name)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Agent.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):  
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange"><code class="flex name class">
<span>class <span class="ident">Exchange</span></span>
<span>(</span><span>datetime=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exchange():
    
    def __init__(self, datetime= None):
        self.books = {}
        self.trade_log: List[Trade] = []
        self.datetime = datetime
        self.agents_aum_updates = []

    def __str__(self):
        return &#39;, &#39;.join(ob for ob in self.books)

    def create_asset(self, ticker: str, seed_price=100, seed_bid=.99, seed_ask=1.01):
        &#34;&#34;&#34;_summary_

        Args:
            ticker (str): the ticker of the new asset
            seed_price (int, optional): Price of an initial trade that is created for ease of use. Defaults to 100.
            seed_bid (float, optional): Limit price of an initial buy order, expressed as percentage of the seed_price. Defaults to .99.
            seed_ask (float, optional): Limit price of an initial sell order, expressed as percentage of the seed_price. Defaults to 1.01.
        &#34;&#34;&#34;
        self.books[ticker] = OrderBook(ticker)
        self._process_trade(ticker, 1, seed_price, &#39;init_seed&#39;, &#39;init_seed&#39;,)
        self.limit_buy(ticker, seed_bid, 10, &#39;init_seed&#39;)
        self.limit_sell(ticker, seed_ask, 10, &#39;init_seed&#39;)


    def get_order_book(self, ticker: str) -&gt; OrderBook:
        &#34;&#34;&#34;Returns the OrderBook of a given Asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            OrderBook: the orderbook of the asset.
        &#34;&#34;&#34;
        return self.books[ticker]

    def _process_trade(self, ticker, qty, price, buyer, seller):
        self.trade_log.append(
            Trade(ticker, qty, price, buyer, seller,self.datetime)
        )
        self.agents_aum_updates.extend([[buyer,-qty*price],[seller,qty*price]])
        
    

    def get_latest_trade(self, ticker:str) -&gt; Trade:
        &#34;&#34;&#34;Retrieves the most recent trade of a given asset

        Args:
            ticker (str): the ticker of the trade

        Returns:
            Trade
        &#34;&#34;&#34;
        return next(trade for trade in self.trade_log[::-1] if trade.ticker == ticker)

    def get_trades(self, ticker:str) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Retrieves all past trades of a given asset

        Args:
            ticker (str): the ticker of the asset

        Returns:
            pd.DataFrame: a dataframe containing all trades
        &#34;&#34;&#34;
        return pd.DataFrame.from_records([t.to_dict() for t in self.trade_log if t.ticker == ticker]).set_index(&#39;dt&#39;).sort_index()

    def get_quotes(self, ticker):
        # TODO: if more than one order has the best price, add the quantities.
        # TODO: check if corresponding quotes exist in order to avoid exceptions
        best_bid = self.books[ticker].bids[0]
        best_ask = self.books[ticker].asks[0]
        quotes = {
            &#39;ticker&#39;: ticker,
            &#39;bid_qty&#39;: best_bid.qty,
            &#39;bid_p&#39;: best_bid.price,
            &#39;ask_qty&#39;: best_ask.qty,
            &#39;ask_p&#39;: best_ask.price,
        }
        return quotes

    def get_best_bid(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;retrieves the current best bid in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset.

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        if self.books[ticker].bids:
            return self.books[ticker].bids[0]

    def get_best_ask(self, ticker:str) -&gt; LimitOrder:
        &#34;&#34;&#34;retrieves the current best ask in the orderbook of an asset

        Args:
            ticker (str): the ticker of the asset.

        Returns:
            LimitOrder
        &#34;&#34;&#34;
        if self.books[ticker].asks:
            return self.books[ticker].asks[0]

    def get_midprice(self, ticker:str) -&gt; float:
        &#34;&#34;&#34;Returns the current midprice of the best bid and ask quotes.

        Args:
            ticker (str): the ticker of the asset

        Returns:
            float: the current midprice
        &#34;&#34;&#34;
        quotes = self.get_quotes(ticker)
        return (quotes[&#39;bid_p&#39;] + quotes[&#39;ask_p&#39;]) / 2

    def limit_buy(self, ticker: str, price: float, qty: int, creator: str):
        price = round(price,2)
        # check if we can match trades before submitting the limit order
        while qty &gt; 0:
            best_ask = self.get_best_ask(ticker)
            if best_ask and price &gt;= best_ask.price:
                trade_qty = min(qty, best_ask.qty)
                self._process_trade(ticker, trade_qty,
                                    best_ask.price, creator, best_ask.creator)
                qty -= trade_qty
                self.books[ticker].asks[0].qty -= trade_qty
                self.books[ticker].asks = [
                    ask for ask in self.books[ticker].asks if ask.qty &gt; 0]
            else:
                break
        queue = len(self.books[ticker].bids)
        for idx, order in enumerate(self.books[ticker].bids):
            if price &gt; order.price:
                queue = idx
                break
        new_order = LimitOrder(ticker, price, qty, creator, OrderSide.BUY, self.datetime)
        self.books[ticker].bids.insert(queue, new_order)
        return new_order


    def limit_sell(self, ticker: str, price: float, qty: int, creator: str):
        price = round(price,2)
        # check if we can match trades before submitting the limit order
        while qty &gt; 0:
            best_bid = self.get_best_bid(ticker)
            if best_bid and price &lt;= best_bid.price:
                trade_qty = min(qty, best_bid.qty)
                self._process_trade(ticker, trade_qty,
                                    best_bid.price, best_bid.creator, creator)
                qty -= trade_qty
                self.books[ticker].bids[0].qty -= trade_qty
                self.books[ticker].bids = [
                    bid for bid in self.books[ticker].bids if bid.qty &gt; 0]
            else:
                break
        queue = len(self.books[ticker].asks)
        for idx, order in enumerate(self.books[ticker].asks):
            if price &lt; order.price:
                queue = idx
                break
        new_order = LimitOrder(ticker, price, qty, creator, OrderSide.SELL, self.datetime)
        self.books[ticker].asks.insert(queue, new_order)
        return new_order

    def cancel_order(self, id):
        for book in self.exchange.books:
            bid = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].bids) if o.id == id),None)
            if bid:
                self.exchange.books[book].bids[bid[0]]
                self.exchange.books[book].bids.pop(bid[0])
                return bid
            ask = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].asks) if o.id == id),None)
            if ask:
                self.exchange.books[book].asks.pop(ask[0])
                return ask
        return None

    def cancel_all_orders(self, agent, ticker):
        self.books[ticker].bids = [b for b in self.books[ticker].bids if b.creator != agent]
        self.books[ticker].asks = [a for a in self.books[ticker].asks if a.creator != agent]
        return None

    def market_buy(self, ticker: str, qty: int, buyer: str):
        for idx, ask in enumerate(self.books[ticker].asks):
            trade_qty = min(ask.qty, qty)
            self.books[ticker].asks[idx].qty -= trade_qty
            qty -= trade_qty
            self._process_trade(ticker, trade_qty,
                                ask.price, buyer, ask.creator)
            if qty == 0:
                break
        self.books[ticker].asks = [
            ask for ask in self.books[ticker].asks if ask.qty &gt; 0]

    def market_sell(self, ticker: str, qty: int, seller: str):
        for idx, bid in enumerate(self.books[ticker].bids):
            trade_qty = min(bid.qty, qty)
            self.books[ticker].bids[idx].qty -= trade_qty
            qty -= trade_qty
            self._process_trade(ticker, trade_qty,
                                bid.price, bid.creator, seller)
            if qty == 0:
                break
        self.books[ticker].bids = [
            bid for bid in self.books[ticker].bids if bid.qty &gt; 0]

    def _set_datetime(self, dt):
        self.datetime = dt</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exchange.source.qmr_exchange.Exchange.cancel_all_orders"><code class="name flex">
<span>def <span class="ident">cancel_all_orders</span></span>(<span>self, agent, ticker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_all_orders(self, agent, ticker):
    self.books[ticker].bids = [b for b in self.books[ticker].bids if b.creator != agent]
    self.books[ticker].asks = [a for a in self.books[ticker].asks if a.creator != agent]
    return None</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.cancel_order"><code class="name flex">
<span>def <span class="ident">cancel_order</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_order(self, id):
    for book in self.exchange.books:
        bid = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].bids) if o.id == id),None)
        if bid:
            self.exchange.books[book].bids[bid[0]]
            self.exchange.books[book].bids.pop(bid[0])
            return bid
        ask = next(([idx,o] for idx, o in enumerate(self.exchange.books[book].asks) if o.id == id),None)
        if ask:
            self.exchange.books[book].asks.pop(ask[0])
            return ask
    return None</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.create_asset"><code class="name flex">
<span>def <span class="ident">create_asset</span></span>(<span>self, ticker: str, seed_price=100, seed_bid=0.99, seed_ask=1.01)</span>
</code></dt>
<dd>
<div class="desc"><p><em>summary</em></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the new asset</dd>
<dt><strong><code>seed_price</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Price of an initial trade that is created for ease of use. Defaults to 100.</dd>
<dt><strong><code>seed_bid</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Limit price of an initial buy order, expressed as percentage of the seed_price. Defaults to .99.</dd>
<dt><strong><code>seed_ask</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Limit price of an initial sell order, expressed as percentage of the seed_price. Defaults to 1.01.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_asset(self, ticker: str, seed_price=100, seed_bid=.99, seed_ask=1.01):
    &#34;&#34;&#34;_summary_

    Args:
        ticker (str): the ticker of the new asset
        seed_price (int, optional): Price of an initial trade that is created for ease of use. Defaults to 100.
        seed_bid (float, optional): Limit price of an initial buy order, expressed as percentage of the seed_price. Defaults to .99.
        seed_ask (float, optional): Limit price of an initial sell order, expressed as percentage of the seed_price. Defaults to 1.01.
    &#34;&#34;&#34;
    self.books[ticker] = OrderBook(ticker)
    self._process_trade(ticker, 1, seed_price, &#39;init_seed&#39;, &#39;init_seed&#39;,)
    self.limit_buy(ticker, seed_bid, 10, &#39;init_seed&#39;)
    self.limit_sell(ticker, seed_ask, 10, &#39;init_seed&#39;)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_best_ask"><code class="name flex">
<span>def <span class="ident">get_best_ask</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>retrieves the current best ask in the orderbook of an asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LimitOrder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_ask(self, ticker:str) -&gt; LimitOrder:
    &#34;&#34;&#34;retrieves the current best ask in the orderbook of an asset

    Args:
        ticker (str): the ticker of the asset.

    Returns:
        LimitOrder
    &#34;&#34;&#34;
    if self.books[ticker].asks:
        return self.books[ticker].asks[0]</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_best_bid"><code class="name flex">
<span>def <span class="ident">get_best_bid</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></span>
</code></dt>
<dd>
<div class="desc"><p>retrieves the current best bid in the orderbook of an asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LimitOrder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_bid(self, ticker:str) -&gt; LimitOrder:
    &#34;&#34;&#34;retrieves the current best bid in the orderbook of an asset

    Args:
        ticker (str): the ticker of the asset.

    Returns:
        LimitOrder
    &#34;&#34;&#34;
    if self.books[ticker].bids:
        return self.books[ticker].bids[0]</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_latest_trade"><code class="name flex">
<span>def <span class="ident">get_latest_trade</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.Trade" href="#exchange.source.qmr_exchange.Trade">Trade</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the most recent trade of a given asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the trade</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Trade</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_trade(self, ticker:str) -&gt; Trade:
    &#34;&#34;&#34;Retrieves the most recent trade of a given asset

    Args:
        ticker (str): the ticker of the trade

    Returns:
        Trade
    &#34;&#34;&#34;
    return next(trade for trade in self.trade_log[::-1] if trade.ticker == ticker)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_midprice"><code class="name flex">
<span>def <span class="ident">get_midprice</span></span>(<span>self, ticker: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current midprice of the best bid and ask quotes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the current midprice</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_midprice(self, ticker:str) -&gt; float:
    &#34;&#34;&#34;Returns the current midprice of the best bid and ask quotes.

    Args:
        ticker (str): the ticker of the asset

    Returns:
        float: the current midprice
    &#34;&#34;&#34;
    quotes = self.get_quotes(ticker)
    return (quotes[&#39;bid_p&#39;] + quotes[&#39;ask_p&#39;]) / 2</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_order_book"><code class="name flex">
<span>def <span class="ident">get_order_book</span></span>(<span>self, ticker: str) ‑> <a title="exchange.source.qmr_exchange.OrderBook" href="#exchange.source.qmr_exchange.OrderBook">OrderBook</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the OrderBook of a given Asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="exchange.source.qmr_exchange.OrderBook" href="#exchange.source.qmr_exchange.OrderBook">OrderBook</a></code></dt>
<dd>the orderbook of the asset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_order_book(self, ticker: str) -&gt; OrderBook:
    &#34;&#34;&#34;Returns the OrderBook of a given Asset

    Args:
        ticker (str): the ticker of the asset

    Returns:
        OrderBook: the orderbook of the asset.
    &#34;&#34;&#34;
    return self.books[ticker]</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_quotes"><code class="name flex">
<span>def <span class="ident">get_quotes</span></span>(<span>self, ticker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_quotes(self, ticker):
    # TODO: if more than one order has the best price, add the quantities.
    # TODO: check if corresponding quotes exist in order to avoid exceptions
    best_bid = self.books[ticker].bids[0]
    best_ask = self.books[ticker].asks[0]
    quotes = {
        &#39;ticker&#39;: ticker,
        &#39;bid_qty&#39;: best_bid.qty,
        &#39;bid_p&#39;: best_bid.price,
        &#39;ask_qty&#39;: best_ask.qty,
        &#39;ask_p&#39;: best_ask.price,
    }
    return quotes</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.get_trades"><code class="name flex">
<span>def <span class="ident">get_trades</span></span>(<span>self, ticker: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all past trades of a given asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the ticker of the asset</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>a dataframe containing all trades</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trades(self, ticker:str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Retrieves all past trades of a given asset

    Args:
        ticker (str): the ticker of the asset

    Returns:
        pd.DataFrame: a dataframe containing all trades
    &#34;&#34;&#34;
    return pd.DataFrame.from_records([t.to_dict() for t in self.trade_log if t.ticker == ticker]).set_index(&#39;dt&#39;).sort_index()</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.limit_buy"><code class="name flex">
<span>def <span class="ident">limit_buy</span></span>(<span>self, ticker: str, price: float, qty: int, creator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_buy(self, ticker: str, price: float, qty: int, creator: str):
    price = round(price,2)
    # check if we can match trades before submitting the limit order
    while qty &gt; 0:
        best_ask = self.get_best_ask(ticker)
        if best_ask and price &gt;= best_ask.price:
            trade_qty = min(qty, best_ask.qty)
            self._process_trade(ticker, trade_qty,
                                best_ask.price, creator, best_ask.creator)
            qty -= trade_qty
            self.books[ticker].asks[0].qty -= trade_qty
            self.books[ticker].asks = [
                ask for ask in self.books[ticker].asks if ask.qty &gt; 0]
        else:
            break
    queue = len(self.books[ticker].bids)
    for idx, order in enumerate(self.books[ticker].bids):
        if price &gt; order.price:
            queue = idx
            break
    new_order = LimitOrder(ticker, price, qty, creator, OrderSide.BUY, self.datetime)
    self.books[ticker].bids.insert(queue, new_order)
    return new_order</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.limit_sell"><code class="name flex">
<span>def <span class="ident">limit_sell</span></span>(<span>self, ticker: str, price: float, qty: int, creator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit_sell(self, ticker: str, price: float, qty: int, creator: str):
    price = round(price,2)
    # check if we can match trades before submitting the limit order
    while qty &gt; 0:
        best_bid = self.get_best_bid(ticker)
        if best_bid and price &lt;= best_bid.price:
            trade_qty = min(qty, best_bid.qty)
            self._process_trade(ticker, trade_qty,
                                best_bid.price, best_bid.creator, creator)
            qty -= trade_qty
            self.books[ticker].bids[0].qty -= trade_qty
            self.books[ticker].bids = [
                bid for bid in self.books[ticker].bids if bid.qty &gt; 0]
        else:
            break
    queue = len(self.books[ticker].asks)
    for idx, order in enumerate(self.books[ticker].asks):
        if price &lt; order.price:
            queue = idx
            break
    new_order = LimitOrder(ticker, price, qty, creator, OrderSide.SELL, self.datetime)
    self.books[ticker].asks.insert(queue, new_order)
    return new_order</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.market_buy"><code class="name flex">
<span>def <span class="ident">market_buy</span></span>(<span>self, ticker: str, qty: int, buyer: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def market_buy(self, ticker: str, qty: int, buyer: str):
    for idx, ask in enumerate(self.books[ticker].asks):
        trade_qty = min(ask.qty, qty)
        self.books[ticker].asks[idx].qty -= trade_qty
        qty -= trade_qty
        self._process_trade(ticker, trade_qty,
                            ask.price, buyer, ask.creator)
        if qty == 0:
            break
    self.books[ticker].asks = [
        ask for ask in self.books[ticker].asks if ask.qty &gt; 0]</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Exchange.market_sell"><code class="name flex">
<span>def <span class="ident">market_sell</span></span>(<span>self, ticker: str, qty: int, seller: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def market_sell(self, ticker: str, qty: int, seller: str):
    for idx, bid in enumerate(self.books[ticker].bids):
        trade_qty = min(bid.qty, qty)
        self.books[ticker].bids[idx].qty -= trade_qty
        qty -= trade_qty
        self._process_trade(ticker, trade_qty,
                            bid.price, bid.creator, seller)
        if qty == 0:
            break
    self.books[ticker].bids = [
        bid for bid in self.books[ticker].bids if bid.qty &gt; 0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.LimitOrder"><code class="flex name class">
<span>class <span class="ident">LimitOrder</span></span>
<span>(</span><span>ticker, price, qty, creator, side, dt=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LimitOrder():

    def __init__(self, ticker, price, qty, creator, side, dt=None):
        self.id = get_random_string()
        self.ticker: str = ticker
        self.price: Decimal = price
        self.type: OrderSide = side
        self.qty: int = qty
        self.creator: str = creator
        self.dt: datetime = dt if dt else datetime.now()

    def to_dict(self):
        return {
            &#39;id&#39;: self.id,
            &#39;ticker&#39;: self.ticker,
            &#39;price&#39;: self.price,
            &#39;qty&#39;: self.qty,
            &#39;creator&#39;: self.creator,
            &#39;dt&#39;: self.dt
        }

    def __repr__(self):
        return f&#39;&lt;LimitOrder: {self.ticker} {self.qty}@{self.price}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;LimitOrder: {self.ticker} {self.qty}@{self.price}&gt;&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exchange.source.qmr_exchange.LimitOrder.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    return {
        &#39;id&#39;: self.id,
        &#39;ticker&#39;: self.ticker,
        &#39;price&#39;: self.price,
        &#39;qty&#39;: self.qty,
        &#39;creator&#39;: self.creator,
        &#39;dt&#39;: self.dt
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.OrderBook"><code class="flex name class">
<span>class <span class="ident">OrderBook</span></span>
<span>(</span><span>ticker: str)</span>
</code></dt>
<dd>
<div class="desc"><p>An OrderBook contains all the relevant trading data of a given asset. It contains the list of bids and asks, ordered by their place in the queue.</p>
<p><em>summary</em></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ticker</code></strong> :&ensp;<code>str</code></dt>
<dd>the corresponding asset that is going to be traded in the OrderBook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrderBook():
    &#34;&#34;&#34;An OrderBook contains all the relevant trading data of a given asset. It contains the list of bids and asks, ordered by their place in the queue.
    &#34;&#34;&#34;
    def __init__(self, ticker:str):
        &#34;&#34;&#34;_summary_

        Args:
            ticker (str): the corresponding asset that is going to be traded in the OrderBook.
        &#34;&#34;&#34;
        self.ticker = ticker
        self.bids: List[LimitOrder] = []
        self.asks: List[LimitOrder] = []

    def __repr__(self):
        return f&#39;&lt;OrderBook: {self.ticker}&gt;&#39;

    def __str__(self):
        return f&#39;&lt;OrderBook: {self.ticker}&gt;&#39;
    


    @property
    def df(self) -&gt; dict:
        &#34;&#34;&#34;_summary_

        Returns:
            dict: dictionary with two dataframes corresponding to the bids and asks of the OrderBook
        &#34;&#34;&#34;
        return {
            &#39;bids&#39;: pd.DataFrame.from_records([b.to_dict() for b in self.bids]),
            &#39;asks&#39;: pd.DataFrame.from_records([a.to_dict() for a in self.asks])
        }</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exchange.source.qmr_exchange.OrderBook.df"><code class="name">var <span class="ident">df</span> : dict</code></dt>
<dd>
<div class="desc"><p><em>summary</em></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>dictionary with two dataframes corresponding to the bids and asks of the OrderBook</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def df(self) -&gt; dict:
    &#34;&#34;&#34;_summary_

    Returns:
        dict: dictionary with two dataframes corresponding to the bids and asks of the OrderBook
    &#34;&#34;&#34;
    return {
        &#39;bids&#39;: pd.DataFrame.from_records([b.to_dict() for b in self.bids]),
        &#39;asks&#39;: pd.DataFrame.from_records([a.to_dict() for a in self.asks])
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.OrderSide"><code class="flex name class">
<span>class <span class="ident">OrderSide</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrderSide(Enum):
    BUY = &#39;buy&#39;
    SELL = &#39;sell&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchange.source.qmr_exchange.OrderSide.BUY"><code class="name">var <span class="ident">BUY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchange.source.qmr_exchange.OrderSide.SELL"><code class="name">var <span class="ident">SELL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.Simulator"><code class="flex name class">
<span>class <span class="ident">Simulator</span></span>
<span>(</span><span>from_date=datetime.datetime(2022, 1, 1, 0, 0), to_date=datetime.datetime(2022, 12, 31, 0, 0), time_unit='day')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulator():
    def __init__(self, from_date=datetime(2022,1,1), to_date=datetime(2022,12,31), time_unit=&#39;day&#39;):
        self.datetime_range = iter(get_datetime_range(from_date,to_date,time_unit))
        self.dt = from_date
        self.agents = []
        self.exchange = Exchange(datetime=from_date)

    
    def add_agent(self,agent:Agent):
        # TODO: check that no existing agent already has the same name
        agent._set_exchange(self.exchange)
        self.agents.append(agent)

    def next(self):
        try:
            self.exchange._set_datetime(self.dt)
            for agent in self.agents:
                agent.next()
            self.dt = next(self.datetime_range)
            self.__update_agents_aum()
            return True
        except StopIteration:
            return False
    def run(self):
        while True:
            if not self.next():
                break

    def get_price_bars(self, bar_size=&#39;1D&#39;):
        df = self.trades.resample(bar_size).agg({&#39;price&#39;: &#39;ohlc&#39;, &#39;qty&#39;: &#39;sum&#39;})
        df.columns = df.columns.droplevel()
        df.rename(columns={&#39;qty&#39;:&#39;volume&#39;},inplace=True)
        return df

    @property
    def trades(self):
        return pd.DataFrame.from_records([t.to_dict() for t in self.exchange.trade_log]).set_index(&#39;dt&#39;)

    def __update_agents_aum(self):
        for update in self.exchange.agents_aum_updates:
            agent_idx = self.__get_agent_index(update[0])
            # Check if not None because initial seed is not an agent
            if agent_idx:
                self.agents[agent_idx].aum += update[1]
        self.exchange.agents_aum_updates = []


    def __get_agent_index(self,agent_name):
        return next((index for (index, d) in enumerate(self.agents) if d.name == agent_name), None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exchange.source.qmr_exchange.Simulator.trades"><code class="name">var <span class="ident">trades</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trades(self):
    return pd.DataFrame.from_records([t.to_dict() for t in self.exchange.trade_log]).set_index(&#39;dt&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchange.source.qmr_exchange.Simulator.add_agent"><code class="name flex">
<span>def <span class="ident">add_agent</span></span>(<span>self, agent: <a title="exchange.source.qmr_exchange.Agent" href="#exchange.source.qmr_exchange.Agent">Agent</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_agent(self,agent:Agent):
    # TODO: check that no existing agent already has the same name
    agent._set_exchange(self.exchange)
    self.agents.append(agent)</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Simulator.get_price_bars"><code class="name flex">
<span>def <span class="ident">get_price_bars</span></span>(<span>self, bar_size='1D')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_price_bars(self, bar_size=&#39;1D&#39;):
    df = self.trades.resample(bar_size).agg({&#39;price&#39;: &#39;ohlc&#39;, &#39;qty&#39;: &#39;sum&#39;})
    df.columns = df.columns.droplevel()
    df.rename(columns={&#39;qty&#39;:&#39;volume&#39;},inplace=True)
    return df</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Simulator.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    try:
        self.exchange._set_datetime(self.dt)
        for agent in self.agents:
            agent.next()
        self.dt = next(self.datetime_range)
        self.__update_agents_aum()
        return True
    except StopIteration:
        return False</code></pre>
</details>
</dd>
<dt id="exchange.source.qmr_exchange.Simulator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    while True:
        if not self.next():
            break</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchange.source.qmr_exchange.Trade"><code class="flex name class">
<span>class <span class="ident">Trade</span></span>
<span>(</span><span>ticker, qty, price, buyer, seller, dt=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trade():
    def __init__(self, ticker, qty, price, buyer, seller, dt=None):
        self.ticker = ticker
        self.qty = qty
        self.price = price
        self.buyer = buyer
        self.seller = seller
        self.dt = dt if dt else datetime.now()

    def __repr__(self):
        return f&#39;&lt;Trade: {self.ticker} {self.qty}@{self.price} {self.dt}&gt;&#39;

    def to_dict(self):
        return {
            &#39;dt&#39;: self.dt,
            &#39;ticker&#39;: self.ticker,
            &#39;qty&#39;: self.qty,
            &#39;price&#39;: self.price,
            &#39;buyer&#39;: self.buyer,
            &#39;seller&#39;: self.seller
        }</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exchange.source.qmr_exchange.Trade.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    return {
        &#39;dt&#39;: self.dt,
        &#39;ticker&#39;: self.ticker,
        &#39;qty&#39;: self.qty,
        &#39;price&#39;: self.price,
        &#39;buyer&#39;: self.buyer,
        &#39;seller&#39;: self.seller
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchange.source" href="index.html">exchange.source</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchange.source.qmr_exchange.Agent" href="#exchange.source.qmr_exchange.Agent">Agent</a></code></h4>
<ul class="two-column">
<li><code><a title="exchange.source.qmr_exchange.Agent.cancel_all_orders" href="#exchange.source.qmr_exchange.Agent.cancel_all_orders">cancel_all_orders</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.cancel_order" href="#exchange.source.qmr_exchange.Agent.cancel_order">cancel_order</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_best_ask" href="#exchange.source.qmr_exchange.Agent.get_best_ask">get_best_ask</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_best_bid" href="#exchange.source.qmr_exchange.Agent.get_best_bid">get_best_bid</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_latest_trade" href="#exchange.source.qmr_exchange.Agent.get_latest_trade">get_latest_trade</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_midprice" href="#exchange.source.qmr_exchange.Agent.get_midprice">get_midprice</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_order_book" href="#exchange.source.qmr_exchange.Agent.get_order_book">get_order_book</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_quotes" href="#exchange.source.qmr_exchange.Agent.get_quotes">get_quotes</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.get_trades" href="#exchange.source.qmr_exchange.Agent.get_trades">get_trades</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.limit_buy" href="#exchange.source.qmr_exchange.Agent.limit_buy">limit_buy</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.limit_sell" href="#exchange.source.qmr_exchange.Agent.limit_sell">limit_sell</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.market_buy" href="#exchange.source.qmr_exchange.Agent.market_buy">market_buy</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.market_sell" href="#exchange.source.qmr_exchange.Agent.market_sell">market_sell</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Agent.next" href="#exchange.source.qmr_exchange.Agent.next">next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.Exchange" href="#exchange.source.qmr_exchange.Exchange">Exchange</a></code></h4>
<ul class="two-column">
<li><code><a title="exchange.source.qmr_exchange.Exchange.cancel_all_orders" href="#exchange.source.qmr_exchange.Exchange.cancel_all_orders">cancel_all_orders</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.cancel_order" href="#exchange.source.qmr_exchange.Exchange.cancel_order">cancel_order</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.create_asset" href="#exchange.source.qmr_exchange.Exchange.create_asset">create_asset</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_best_ask" href="#exchange.source.qmr_exchange.Exchange.get_best_ask">get_best_ask</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_best_bid" href="#exchange.source.qmr_exchange.Exchange.get_best_bid">get_best_bid</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_latest_trade" href="#exchange.source.qmr_exchange.Exchange.get_latest_trade">get_latest_trade</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_midprice" href="#exchange.source.qmr_exchange.Exchange.get_midprice">get_midprice</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_order_book" href="#exchange.source.qmr_exchange.Exchange.get_order_book">get_order_book</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_quotes" href="#exchange.source.qmr_exchange.Exchange.get_quotes">get_quotes</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.get_trades" href="#exchange.source.qmr_exchange.Exchange.get_trades">get_trades</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.limit_buy" href="#exchange.source.qmr_exchange.Exchange.limit_buy">limit_buy</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.limit_sell" href="#exchange.source.qmr_exchange.Exchange.limit_sell">limit_sell</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.market_buy" href="#exchange.source.qmr_exchange.Exchange.market_buy">market_buy</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Exchange.market_sell" href="#exchange.source.qmr_exchange.Exchange.market_sell">market_sell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.LimitOrder" href="#exchange.source.qmr_exchange.LimitOrder">LimitOrder</a></code></h4>
<ul class="">
<li><code><a title="exchange.source.qmr_exchange.LimitOrder.to_dict" href="#exchange.source.qmr_exchange.LimitOrder.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.OrderBook" href="#exchange.source.qmr_exchange.OrderBook">OrderBook</a></code></h4>
<ul class="">
<li><code><a title="exchange.source.qmr_exchange.OrderBook.df" href="#exchange.source.qmr_exchange.OrderBook.df">df</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.OrderSide" href="#exchange.source.qmr_exchange.OrderSide">OrderSide</a></code></h4>
<ul class="">
<li><code><a title="exchange.source.qmr_exchange.OrderSide.BUY" href="#exchange.source.qmr_exchange.OrderSide.BUY">BUY</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.OrderSide.SELL" href="#exchange.source.qmr_exchange.OrderSide.SELL">SELL</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.Simulator" href="#exchange.source.qmr_exchange.Simulator">Simulator</a></code></h4>
<ul class="">
<li><code><a title="exchange.source.qmr_exchange.Simulator.add_agent" href="#exchange.source.qmr_exchange.Simulator.add_agent">add_agent</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Simulator.get_price_bars" href="#exchange.source.qmr_exchange.Simulator.get_price_bars">get_price_bars</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Simulator.next" href="#exchange.source.qmr_exchange.Simulator.next">next</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Simulator.run" href="#exchange.source.qmr_exchange.Simulator.run">run</a></code></li>
<li><code><a title="exchange.source.qmr_exchange.Simulator.trades" href="#exchange.source.qmr_exchange.Simulator.trades">trades</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchange.source.qmr_exchange.Trade" href="#exchange.source.qmr_exchange.Trade">Trade</a></code></h4>
<ul class="">
<li><code><a title="exchange.source.qmr_exchange.Trade.to_dict" href="#exchange.source.qmr_exchange.Trade.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>